<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="https://www.w3.org/1999/xhtml">
<head>
  <link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400,600" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Cousine&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <link rel="icon" type="image/ico" href="/images/favicon.ico" />
  <link rel="shortcut icon" type="image/png" href="/images/favicon.png" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Solar2D Documentation — Developer Guides | Physics</title>
  <meta name="description" content="Solar2D lets you build games/apps for all major platforms including iOS, Android, Kindle, Apple TV, Android TV, macOS, and Windows. Get the free toolset!" />
  <link rel="stylesheet" href="../../../css/style.css" />
  <link rel="stylesheet" href="../../../css/shCoreDefault.css" />
<script src="https://corona-cdn.coronalabs.com/js/docs.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-9574984-14', 'auto');
  ga('send', 'pageview');
</script>
</head>
<body>
<div class="header"></div>
<div class="title">
	<span class="titleimg" onclick="window.location='https://docs.coronalabs.com/'"></span>
	<div id="nav">
		<ul>
<li><a href="../../../guide/programming/index.html">Getting Started</a></li>
<li><a href="../../../guide/index.html">Guides</a></li>
<li><a href="../../../api/index.html">API Reference</a></li>
<li><a href="../../../tutorial/index.html">Tutorials</a></li>
<li><a href="../../../plugin/index.html">Plugins</a></li>
<li><a href="../../../native/index.html">Solar2D Native</a></li>
<li><a href="../../../coronacards/index.html">CoronaCards</a></li>
</ul>

		<!--
		<div id="resources-link"><a href="https://coronalabs.com/resources/">Corona Resources</a></div>
		-->
	</div>
</div>

<div class="SearchBar">
  <form action="https://www.google.com/cse" id="cse-search-box">
  <input type="hidden" name="cx" value="009283852522218786394:g40gqt2m6rq" />
  <input type="hidden" name="ie" value="UTF-8" />
  <input type="text" placeholder="Search" name="q" id="q" autocomplete="off" size="40" />
  <input type="submit" name="sa" value="Search" />
  </form>
</div>
<div id="TOC">
<ul>
<li><a href="#physics-bodies">Physics Bodies</a><ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#creating-bodies">Creating Bodies</a><ul>
<li><a href="#physical-properties">Physical Properties</a><ul>
<li><a href="#density">Density</a></li>
<li><a href="#friction">Friction</a></li>
<li><a href="#bounce">Bounce</a></li>
</ul></li>
<li><a href="#body-type">Body Type</a><ul>
<li><a href="#dynamic">dynamic</a></li>
<li><a href="#static">static</a></li>
<li><a href="#kinematic">kinematic</a></li>
</ul></li>
<li><a href="#rectangular-bodies">Rectangular Bodies</a></li>
<li><a href="#circular-bodies">Circular Bodies</a></li>
<li><a href="#polygonal-bodies">Polygonal Bodies</a></li>
<li><a href="#multi-element-bodies">Multi-Element Bodies</a></li>
<li><a href="#offsetangled-rectangular-bodies">Offset/Angled Rectangular Bodies</a></li>
<li><a href="#edge-shape-chain-body">Edge Shape (Chain) Body</a></li>
<li><a href="#outline-bodies">Outline Bodies</a></li>
</ul></li>
<li><a href="#destroying-bodies">Destroying Bodies</a></li>
<li><a href="#sensors">Sensors</a></li>
<li><a href="#body-properties">Body Properties</a><ul>
<li><a href="#object.bodytype">object.bodyType</a></li>
<li><a href="#object.isawake">object.isAwake</a></li>
<li><a href="#object.issleepingallowed">object.isSleepingAllowed</a></li>
<li><a href="#object.isbodyactive">object.isBodyActive</a></li>
<li><a href="#object.issensor">object.isSensor</a></li>
<li><a href="#object.isfixedrotation">object.isFixedRotation</a></li>
<li><a href="#object.gravityscale">object.gravityScale</a></li>
<li><a href="#object.angularvelocity">object.angularVelocity</a></li>
<li><a href="#object.angulardamping">object.angularDamping</a></li>
<li><a href="#object.lineardamping">object.linearDamping</a></li>
<li><a href="#object.isbullet">object.isBullet</a></li>
</ul></li>
<li><a href="#body-methods">Body Methods</a><ul>
<li><a href="#objectsetlinearvelocity">object:setLinearVelocity()</a></li>
<li><a href="#objectgetlinearvelocity">object:getLinearVelocity()</a></li>
<li><a href="#objectapplyforce">object:applyForce()</a></li>
<li><a href="#objectapplylinearimpulse">object:applyLinearImpulse()</a></li>
<li><a href="#objectapplytorque">object:applyTorque()</a></li>
<li><a href="#objectapplyangularimpulse">object:applyAngularImpulse()</a></li>
<li><a href="#objectresetmassdata">object:resetMassData()</a></li>
</ul></li>
</ul></li>
</ul>
</div>
<div id="breadcrumb">
<a href="https://docs.coronalabs.com">Documentation</a>  ▸  <a href="../../../guide/index.html">Developer Guides</a>  ▸  <a href="../../../guide/physics/index.html">Physics</a>
</div>
<section id="physics-bodies" class="level1">
<h1>Physics Bodies</h1>
<p>This guide discusses how to create Box2D physical bodies in your Corona app, including polygonal and <nobr>multi-element</nobr> bodies.</p>
<div class="guides-toc">
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#create">Creating Bodies</a></li>
<li><a href="#destroy">Destroying Bodies</a></li>
<li><a href="#sensors">Sensors</a></li>
<li><a href="#properties">Body Properties</a></li>
<li><a href="#methods">Body Methods</a></li>
</ul>
</div>
<p><a id="overview"></a></p>
<section id="overview" class="level2">
<h2>Overview</h2>
<p>The physics world is based on the interactions of physical bodies. Corona treats these physical bodies as an extension of its graphics objects. These bodies can be bound to Corona <a href="../../../guide/media/displayObjects/index.html">display objects</a> in a <nobr>one-to-one</nobr> relationship and Corona will automatically handle all position updates and other synchronization tasks.</p>
<p>Standard object read/write attributes like <code>x</code>, <code>y</code>, and <code>rotation</code> should continue to work normally on physical bodies. However, if the object’s <code>bodyType</code> is dynamic, the physics engine may “fight back” against your attempts to move the object manually, since it may be under the constant effect of gravity or other forces.</p>
<p>A display object with a physical body can be deleted in the usual way, using either <a href="../../../api/type/DisplayObject/removeSelf.html">object:removeSelf()</a> or <a href="../../../api/library/display/remove.html">display.remove()</a>. In this case, it will be removed from both the visible screen <strong>and</strong> the physical simulation (the physical body data will be destroyed). Alternatively, you can use <a href="../../../api/library/physics/removeBody.html">physics.removeBody()</a> to remove just the physical body while retaining the core display object on screen. See <a href="#destroy">Destroying Objects</a> for more details and an important note regarding collisions.</p>
<!---

<div class="guide-notebox-imp">
<div class="notebox-title-imp">Important</div>

When you turn a display object into a physical object, the physics engine owns the object and applies its own rules. The engine assumes the anchor point of the object is its __center__, so changing the anchor point may change the object's position as a display object, but not in respect to the physics simulation.

The same applies to scaling the object: you can scale the object up or down, but the physics engine still considers the core physical body as it was before the scaling was applied.

Note that the physics engine's "view" of the object can be seen by setting the draw mode to either `"hybrid"` or `"debug"`.

``````lua
physics.setDrawMode( "hybrid" )
``````
``````lua
physics.setDrawMode( "debug" )
``````

</div>

-->
<p><a id="create"></a></p>
</section>
<section id="creating-bodies" class="level2">
<h2>Creating Bodies</h2>
<p>All physical bodies in Corona are created with the <a href="../../../api/library/physics/addBody.html">physics.addBody()</a> function. This allows you to turn any Corona display object into a simulated physical object with just one line of code, including the assignment of physical properties.</p>
<pre class="brush: lua;">physics.addBody( object, { properties } )</pre>
<section id="physical-properties" class="level3">
<h3>Physical Properties</h3>
<p>All physical bodies possess three core properties, and each can be defined as a key-value pair in the properties table. These properties are optional and the default values will apply unless otherwise specified.</p>
<section id="density" class="level5">
<h5>Density</h5>
<p><code>density</code> is multiplied by the area of the body’s shape to determine its mass. This parameter is based on a standard value of <code>1.0</code> for water, so materials that are lighter than water (such as wood) have a density below <code>1.0</code>, and heavier materials (such as stone) have a density greater than <code>1.0</code>. However, feel free to set density values to whatever feels right for your simulation, since overall object behavior will also depend on the gravity and <nobr>pixels-to-meter</nobr> scale settings (see <a href="../../../guide/physics/physicsSetup/index.html">Physics Setup</a>). The default value is <code>1.0</code>.</p>
</section>
<section id="friction" class="level5">
<h5>Friction</h5>
<p><code>friction</code> may be any non-negative value. A value of <code>0.0</code> means no friction and <code>1.0</code> means fairly strong friction. The default value is <code>0.0</code>.</p>
</section>
<section id="bounce" class="level5">
<h5>Bounce</h5>
<p><code>bounce</code> is the Box2D property known as “restitution,” and it determines how much of an object’s velocity is returned after a collision. Values greater than <code>0.3</code> are fairly “bouncy,” and an object with a bounce value of <code>1.0</code> will rebound forever — for example, if the object is dropped to the ground, it will bounce back up to approximately the height from which it was dropped. Bounce values higher than <code>1.0</code> are valid, and they will actually gain velocity with each collision. The default value is <code>0.2</code>, which is slightly bouncy.</p>
<pre class="brush: lua;">--examples:

local crate = display.newImage( "crate.png", 100, 200 )
physics.addBody( crate, { density=1.0, friction=0.3, bounce=0.2 } )

local balloon = display.newImage( "balloon.png", 200, 200 )
physics.addBody( balloon, { density=0.1, friction=0.1, bounce=0.4 } )</pre>
<p>Note that a pre-declared table of physical attributes can be used multiple times:</p>
<pre class="brush: lua;">local crate1 = display.newImage( "crate1.png", 100, 200 )
local crate2 = display.newImage( "crate2.png", 180, 280 )
 
local crateMaterial = { density=1.0, friction=0.3, bounce=0.2 }
 
physics.addBody( crate1, crateMaterial )
physics.addBody( crate2, crateMaterial )</pre>
<p><a id="bodytype"></a></p>
</section>
</section>
<section id="body-type" class="level3">
<h3>Body Type</h3>
<p>Physical bodies can be one of three types: <strong>dynamic</strong>, <strong>static</strong>, or <strong>kinematic</strong>.</p>
<section id="dynamic" class="level5">
<h5>dynamic</h5>
<p>Dynamic bodies are fully simulated. They can be moved manually in code, but normally they move according to forces like gravity or reactionary collision forces. This is the default body type for physical objects in Box2D. Dynamic bodies can collide with all body types.</p>
</section>
<section id="static" class="level5">
<h5>static</h5>
<p>Static bodies does not move under simulation and they behave as if they have infinite mass. Static bodies can be moved manually by the user, but they do not accept the application of velocity. Static bodies collide only with dynamic bodies, not with other static bodies or kinematic bodies.</p>
</section>
<section id="kinematic" class="level5">
<h5>kinematic</h5>
<p>Kinematic bodies move under simulation only according to their velocity. Kinematic bodies will <strong>not</strong> respond to forces like gravity. They can be moved manually by the user, but normally they are moved by setting their velocities. Kinematic bodies collide only with dynamic bodies, not with other kinematic bodies or static bodies.</p>
<div class="guide-notebox-imp">
<div class="notebox-title-imp">
Important
</div>
<p>As noted, some body types will — or will not — collide with other body types. In a collision between two physical objects, at least <strong>one</strong> of the objects must be dynamic, since this is the only body type which collides with any other type.</p>
</div>
<p>Declaring the body type in Corona is done either inline with the <code>physics.addBody()</code> call or post-creation using <a href="../../../api/type/Body/bodyType.html">object.bodyType</a>.</p>
<pre class="brush: lua;">--inline:
physics.addBody( triangle, "static", { density=1.6, friction=0.5, bounce=0.2 } )

--post-creation:
physics.addBody( triangle, { density=1.6, friction=0.5, bounce=0.2 } )
triangle.bodyType = "static"</pre>
</section>
</section>
<section id="rectangular-bodies" class="level3">
<h3>Rectangular Bodies</h3>
<p>By default, the <code>physics.addBody()</code> constructor will apply a rectangular body that surrounds the edges of the associated image or vector object. This is useful for platforms, large ground bodies, and other simple rectangular objects. Note that this rectangle includes the transparent pixels around an image, if any exist.</p>
<pre class="brush: lua;">local platform = display.newImage( "platform.png", 600, 200 )
physics.addBody( platform, { density=1.0, friction=0.3, bounce=0.2 } )</pre>
<p>If you don’t want the physical body to match this bounding rectangle, you must define more specific shape data using either the circular <code>radius</code> property or a table of polygon coordinates (see below).</p>
<p>When in doubt, use <a href="../../../api/library/physics/setDrawMode.html">physics.setDrawMode()</a> to check how the physics engine is actually considering the object.</p>
</section>
<section id="circular-bodies" class="level3">
<h3>Circular Bodies</h3>
<p>Circular bodies are created by adding the <code>radius</code> parameter to the properties table. This works well for balls, rocks, and other objects that can be considered approximately round when calculating collisions.</p>
<pre class="brush: lua;">local ball = display.newImage( "ball.png", 100, 100 )
physics.addBody( ball, { radius=50, density=1.0, friction=0.3, bounce=0.2 } )</pre>
<p>Note that a non-circular oval does not exist in Box2D collision geometry, since circular bodies exist as a special case. To make an oval body, consider a table of polygon coordinates (see below).</p>
<p><a id="polygonal"></a></p>
</section>
<section id="polygonal-bodies" class="level3">
<h3>Polygonal Bodies</h3>
<p>Polygonal bodies can be created using the <code>shape</code> parameter. This is a Lua table of <strong>x</strong> and <strong>y</strong> coordinate pairs, where each pair defines a vertex point for the shape. These coordinates are specified relative to the <strong>center</strong> of the display object — thus, with <code>(0,0)</code> corresponding to the center of the object, a vertex point of <code>(-20,-10)</code> defines a point 20 pixels to the left of center and 10 pixels above center.</p>
<pre class="brush: lua;">--triangle:
local triangle = display.newImage( "triangle.png" )
triangle.x = 200
triangle.y = 150

--define the shape table (once created, this can be used multiple times)
local triangleShape = { 0,-35, 37,30, -37,30 }

physics.addBody( triangle, { shape=triangleShape, density=1.6, friction=0.5, bounce=0.2 } )


--pentagon:
local pentagon = display.newImage( "pentagon.png" )
pentagon.x = 200
pentagon.y = 50

local pentagonShape = { 0,-37, 37,-10, 23,34, -23,34, -37,-10 }

physics.addBody( pentagon, { shape=pentagonShape, density=3.0, friction=0.8, bounce=0.3 } )</pre>
<div class="guide-notebox-imp">
<div class="notebox-title-imp">
Important
</div>
<ul>
<li><p>Vertex points must be defined in <strong>clockwise</strong> order. The body may appear correct in the <code>hybrid</code> or <code>debug</code> views even if you specify the vertex points in <nobr>counter-clockwise</nobr> order, but collisions will not function properly.</p></li>
<li><p>Polygonal shapes must be entirely <strong>convex</strong>. You cannot create shapes with concave bends, for example a bowl or cup. To accomplish such a task, you must assemble the body from multiple polygons, as explained in <a href="#multielement">Multi-Element Bodies</a> below.</p></li>
<li><p>Polygonal shapes may have a maximum of <strong>8 vertex points</strong> and thus a maximum of 8 sides. If more are required, you must assemble the body from multiple neighboring polygons.</p></li>
</ul>
</div>
<p><a id="multielement"></a></p>
</section>
<section id="multi-element-bodies" class="level3">
<h3>Multi-Element Bodies</h3>
<p>The above examples assume a body with only one element — either a rectangle, circle, or convex polygon. However, in more advanced situations, you will need to construct bodies from <strong>multiple</strong> polygons to achieve more precise collision boundaries. Also, since polygons in Box2D must be <strong>convex</strong>, any object with a concave shape must be constructed by assembling multiple body elements.</p>
<p>When creating multi-element bodies, each element must be specified as a separate <a href="#polygonal">polygonal shape</a>. Although these shapes are declared individually, they will be regarded as part of the overall body and they will not shift/flex independently under the application of physical forces.</p>
<p>The constructor for a multi-element body is essentially the same as the simple polygon constructor — just declare the additional elements after the first:</p>
<pre class="brush: lua;">physics.addBody( object, "static",
    { bodyElement1 },
    { bodyElement2 },
    --etc.
)</pre>
<p>Note that each body element may have its own unique physical properties along with the shape definition for its collision boundaries. For example:</p>
<pre class="brush: lua;">local car = display.newImage( "car.png" )
local roofShape = { -20,-10, 20,-10, 20,10, -20,10 }
local hoodShape = { 0,-35, 37,30, -37,30 }
local trunkShape = { 0,-37, 37,-10, 23,34, -23,34, -37,-10 }

physics.addBody( car, "dynamic",
    { density=3.0, friction=0.5, bounce=0.2, shape=roofShape },
    { density=6.0, friction=0.6, bounce=0.4, shape=hoodShape },
    { density=4.0, friction=0.5, bounce=0.4, shape=trunkShape }
)</pre>
</section>
<section id="offsetangled-rectangular-bodies" class="level3">
<h3>Offset/Angled Rectangular Bodies</h3>
<p>If you want to create a rectangular body that doesn’t span the full width and height of the display object, you can define the <code>box</code> parameter and specify the desired <nobr>key-value</nobr> pairs within it. This type of body can also be offset from the display object’s center and/or set to an angle (rotation) other than <code>0</code>.</p>
<ul>
<li><code>halfWidth</code> — Half of the body width. This property is required.</li>
<li><code>halfHeight</code> — Half of the body height. This property is required.</li>
<li><code>x</code> — The <strong>x</strong> offset (±) from the display object’s center. This property is optional and defaults to <code>0</code>.</li>
<li><code>y</code> — The <strong>y</strong> offset (±) from the display object’s center. This property is optional and defaults to <code>0</code>.</li>
<li><code>angle</code> — The angle (rotation) of the body. This property is optional and defaults to <code>0</code>.</li>
</ul>
<pre class="brush: lua;">local body = display.newRect( 100, 200, 40, 40 )

local offsetRectParams = { halfWidth=5, halfHeight=10, x=10, y=0, angle=60 }

physics.addBody( body, "dynamic", { box=offsetRectParams } )</pre>
</section>
<section id="edge-shape-chain-body" class="level3">
<h3>Edge Shape (Chain) Body</h3>
<p>Edge shape (chain) bodies can be defined via an array of vertices in the <code>chain</code> table. Edge shapes are not restricted to convex angles like polygonal bodies.</p>
<p>Optionally, you can connect (close) the ends of the chain with the boolean <code>connectFirstAndLastChainVertex</code> parameter. If set to <code>true</code>, the first and last vertices will be joined by a straight line. If set to <code>false</code> (default), the edge shape will have disconnected ends.</p>
<pre class="brush: lua;">local body = display.newRect( 150, 200, 40, 40 )

physics.addBody( body, "static",
    {
        chain={ -120,-140, -100,-90, -80,-60, -40,-20, 0,0, 40,0, 70,-10, 110,-20, 140,-20, 180,-10 },
        connectFirstAndLastChainVertex = true
    }
)</pre>
<div class="guide-notebox-imp">
<div class="notebox-title-imp">
Important
</div>
<p>You should not construct an edge shape body with <nobr>self-intersecting</nobr> segments — in other words, your definition of vertices should not result in any segments of the chain intersecting with other segments. Doing so many break the expected collision detection of the shape.</p>
</div>
</section>
<section id="outline-bodies" class="level3">
<h3>Outline Bodies</h3>
<p>If you don’t want to define a specific body shape or multi-element body for a more complex display object, Corona can outline the display object automatically via the <a href="../../../api/library/graphics/newOutline.html">graphics.newOutline()</a> function. Outlined bodies have fewer restrictions than polygonal bodies, for example, an outlined body shape can be either convex or concave.</p>
<pre class="brush: lua;">local image_name = "star.png"

local image_outline = graphics.newOutline( 2, image_name )

local image_star = display.newImageRect( image_name )

physics.addBody( image_star, { outline=image_outline } )</pre>
<p><a id="destroy"></a></p>
</section>
</section>
<section id="destroying-bodies" class="level2">
<h2>Destroying Bodies</h2>
<p>Physical bodies can be destroyed like other display objects, using either <a href="../../../api/type/DisplayObject/removeSelf.html">object:removeSelf()</a> or <a href="../../../api/library/display/remove.html">display.remove()</a>. In this case, the object will be removed from both the visible screen <strong>and</strong> the physical simulation (the physical body data will be destroyed).</p>
<pre class="brush: lua;">object:removeSelf()
--OR:
display.remove( object )</pre>
<p>Alternatively, you can use <a href="../../../api/library/physics/removeBody.html">physics.removeBody()</a> to remove just the physical body while retaining the core display object on screen:</p>
<pre class="brush: lua;">physics.removeBody( object )</pre>
<div class="guide-notebox">
<div class="notebox-title">
Note
</div>
<p>In both cases, the Box2D body will be safely retained until the end of the current world step. However, its Lua reference will be deleted immediately. Therefore, you should avoid accidental, multiple removal of the same Lua object. This may arise when handling object collisions which can potentially trigger multiple event phases before the collision is fully resolved. To prevent this from occurring, use conditional filtering of the <code>event.phase</code>, for example:</p>
<pre class="brush: lua;">local function onCollision( self, event )

    if ( event.phase == "began" ) then
        display.remove( crate1 )
        crate1 = nil
    end
end</pre>
</div>
<p><a id="sensors"></a></p>
</section>
<section id="sensors" class="level2">
<h2>Sensors</h2>
<p>Any body — or any specific element of a multi-element body — can be turned into a sensor. Sensors do not physically interact with other bodies, but they produce <a href="../../../guide/physics/collisionDetection/index.html">collision</a> events when other bodies pass through them. This is useful if you need to detect when an object collides with a specific region (the sensor), but not cause any force reaction as a result.</p>
<p>Setting a body element as a sensor is done either inline with the <code>physics.addBody()</code> call or post-creation using <a href="../../../api/type/Body/isSensor.html">object.isSensor</a>.</p>
<pre class="brush: lua;">--inline:
physics.addBody( goal, "static", { isSensor=true } )

--post-creation:
physics.addBody( goal, "static" )
goal.isSensor = true</pre>
<div class="guide-notebox">
<div class="notebox-title">
Note
</div>
<p>Objects that collide with a sensor will trigger a <code>"began"</code> event phase, just like normal non-sensor objects, and they will also trigger an <code>"ended"</code> event phase when they exit the collision bounds of the sensor. In addition, collision events will occur for <strong>each element</strong> in a <nobr>multi-element</nobr> sensor body.</p>
</div>
<p><a id="properties"></a></p>
</section>
<section id="body-properties" class="level2">
<h2>Body Properties</h2>
<p>In Corona, many of the native Box2D set/get methods have been reduced to simple properties on the display object. The following examples assume that a physical body <code>object</code> has been created using one of the constructor methods.</p>
<section id="object.bodytype" class="level3">
<h3>object.bodyType</h3>
<p><a href="../../../api/type/Body/bodyType.html">object.bodyType</a> is a string value for the type of physical body. Possible values include <code>dynamic</code>, <code>static</code>, or <code>kinematic</code>. See the <a href="#bodytype">Body Type</a> section for details. Note that you cannot change the body type during a collision event, so you must queue this event after a slight, imperceptible delay:</p>
<pre class="brush: lua;">local function onCollisionDelay()
    --change the body type
    object.bodyType = "kinematic"
end

timer.performWithDelay( 10, onCollisionDelay )</pre>
</section>
<section id="object.isawake" class="level3">
<h3>object.isAwake</h3>
<p><a href="../../../api/type/Body/isAwake.html">object.isAwake</a> is the boolean value for the body’s current “awake” state. By default, all physical bodies automatically “sleep” when nothing interacts with them for a couple of seconds, and they stop being simulated until something like a collision wakes them up. This property can either fetch an object’s current state or forcibly wake it up.</p>
</section>
<section id="object.issleepingallowed" class="level3">
<h3>object.isSleepingAllowed</h3>
<p><a href="../../../api/type/Body/isSleepingAllowed.html">object.isSleepingAllowed</a> is the boolean value for whether the body is ever allowed to sleep. Keeping a body awake has a larger performance overhead and usually it’s not necessary because a collision with another body will automatically wake it up. However, forcing a constant awake state is useful in cases such as a tilt gravity simulation, since sleeping bodies do not respond to changes in global gravity.</p>
</section>
<section id="object.isbodyactive" class="level3">
<h3>object.isBodyActive</h3>
<p><a href="../../../api/type/Body/isBodyActive.html">object.isBodyActive</a> is used to set or get the body’s current active state. Inactive bodies are not destroyed, but they are removed from the physics simulation and cease to interact with other bodies. Note that you cannot change the body’s active state during a collision event, so you must queue this event after a slight, imperceptible delay:</p>
<pre class="brush: lua;">local function onCollisionDelay()
    --change the body's active state to false
    object.isBodyActive = false
end

timer.performWithDelay( 10, onCollisionDelay )</pre>
</section>
<section id="object.issensor" class="level3">
<h3>object.isSensor</h3>
<p><a href="../../../api/type/Body/isSensor.html">object.isSensor</a> is a write-only boolean property that sets an internal <code>isSensor=true</code> property across all elements in the body. See the <a href="#sensors">Sensors</a> section for more details. Because this property acts across all body elements, it unconditionally overrides any <code>isSensor</code> settings on the individual elements.</p>
</section>
<section id="object.isfixedrotation" class="level3">
<h3>object.isFixedRotation</h3>
<p><a href="../../../api/type/Body/isFixedRotation.html">object.isFixedRotation</a> is the boolean value for whether the body’s rotation should be locked, even if the body is subjected to off-center forces.</p>
</section>
<section id="object.gravityscale" class="level3">
<h3>object.gravityScale</h3>
<p><a href="../../../api/type/Body/gravityScale.html">object.gravityScale</a> can be used to adjust the gravity effect on a specific body. For example, setting it to <code>0</code> makes the body float, even if other objects in the simulation are subject to normal gravity. The default value is <code>1.0</code>, meaning normal gravity. You can also set the value higher than normal, but be careful since increased gravity can decrease stability.</p>
<pre class="brush: lua;">--make the object float in place, even if the simulation has normal gravity
object.gravityScale = 0</pre>
</section>
<section id="object.angularvelocity" class="level3">
<h3>object.angularVelocity</h3>
<p><a href="../../../api/type/Body/angularVelocity.html">object.angularVelocity</a> is the numerical value of the current angular (rotational) velocity, in degrees per second.</p>
</section>
<section id="object.angulardamping" class="level3">
<h3>object.angularDamping</h3>
<p><a href="../../../api/type/Body/angularDamping.html">object.angularDamping</a> is the numerical value for how much the body’s rotation should be damped — as in, how quickly the rotating object will slow down to a full stop in the rotational sense (not linear). The default is <code>0</code>, meaning the body will rotate at the same velocity indefinitely.</p>
</section>
<section id="object.lineardamping" class="level3">
<h3>object.linearDamping</h3>
<p><a href="../../../api/type/Body/linearDamping.html">object.linearDamping</a> is the numerical value for how much the body’s linear motion is damped — as in, how quickly the object will slow down to a full stop in the linear sense (not rotational). The default is <code>0</code>, meaning the body will move at the same velocity indefinitely.</p>
<p>Note that the application of constant linear velocity is accomplished through the <a href="../../../api/type/Body/setLinearVelocity.html">object:setLinearVelocity()</a> method described below, unlike the angular/rotational velocity which is set via the <a href="../../../api/type/Body/angularVelocity.html">object.angularVelocity</a> property.</p>
</section>
<section id="object.isbullet" class="level3">
<h3>object.isBullet</h3>
<p><a href="../../../api/type/Body/isBullet.html">object.isBullet</a> is the boolean value for whether the body should be treated as a “bullet” in respect to collision detection. Bullets are subject to <strong>continuous</strong> collision detection rather than periodic detection. This is computationally more expensive, but it can prevent <nobr>fast-moving</nobr> objects from passing through solid barriers.</p>
<p><a id="methods"></a></p>
</section>
</section>
<section id="body-methods" class="level2">
<h2>Body Methods</h2>
<p>The following examples assume that a physical body <code>object</code> has been created using one of the constructor methods.</p>
<section id="objectsetlinearvelocity" class="level3">
<h3>object:setLinearVelocity()</h3>
<p><a href="../../../api/type/Body/setLinearVelocity.html">object:setLinearVelocity()</a> sets the <strong>x</strong> and <strong>y</strong> components for the body’s linear velocity, in pixels per second.</p>
<pre class="brush: lua;">object:setLinearVelocity( 2, 4 )</pre>
</section>
<section id="objectgetlinearvelocity" class="level3">
<h3>object:getLinearVelocity()</h3>
<p><a href="../../../api/type/Body/getLinearVelocity.html">object:getLinearVelocity()</a> returns the <strong>x</strong> and <strong>y</strong> components for the body’s linear velocity, in pixels per second. This function takes advantage of the fact that Lua can return multiple values, in this case both linear velocities.</p>
<pre class="brush: lua;">local vx, vy = object:getLinearVelocity()
print( "Linear X velocity = " .. vx )
print( "Linear Y velocity = " .. vy )</pre>
</section>
<section id="objectapplyforce" class="level3">
<h3>object:applyForce()</h3>
<p><a href="../../../api/type/Body/applyForce.html">object:applyForce()</a> applies the specified <strong>x</strong> and <strong>y</strong> components of a linear force at a given point within world coordinates. If the target point is the body’s center of mass, it will tend to push the body in a straight line. If the target point is offset from the center, the body will spin around its center of mass. For symmetrical objects, the center of mass and the center of the object will have the same position:</p>
<pre class="brush: lua;">object:applyForce( 500, 2000, object.x, object.y )</pre>
</section>
<section id="objectapplylinearimpulse" class="level3">
<h3>object:applyLinearImpulse()</h3>
<p><a href="../../../api/type/Body/applyLinearImpulse.html">object:applyLinearImpulse()</a> is similar to <code>object:applyForce()</code>, except that an <strong>impulse</strong> is a single, momentary jolt of force. See the <a href="#forcevsimpulse">Force and Impulse</a> notes below. Like <code>object:applyForce()</code>, the impulse can be applied to any point on the body (either the center of mass or an offset point).</p>
<pre class="brush: lua;">object:applyLinearImpulse( 60, 20, object.x, object.y )</pre>
</section>
<section id="objectapplytorque" class="level3">
<h3>object:applyTorque()</h3>
<p><a href="../../../api/type/Body/applyTorque.html">object:applyTorque()</a> applies a rotational force to the body. Positive values will result in clockwise torque; negative values will result in counter-clockwise torque. The body will rotate about its center of mass.</p>
</section>
<section id="objectapplyangularimpulse" class="level3">
<h3>object:applyAngularImpulse()</h3>
<p><a href="../../../api/type/Body/applyAngularImpulse.html">object:applyAngularImpulse()</a> is similar to <code>object:applyTorque()</code>, except that an <strong>impulse</strong> is a single, momentary jolt of force. See the <a href="#forcevsimpulse">Force and Impulse</a> notes below.</p>
</section>
<section id="objectresetmassdata" class="level3">
<h3>object:resetMassData()</h3>
<p><a href="../../../api/type/Body/resetMassData.html">object:resetMassData()</a> is useful if the default mass data for the body has been overridden. This function resets it to the mass calculated from the shapes.</p>
<div class="guide-notebox">
<div class="notebox-title">
Force and Impulse
</div>
<p>A common question is whether to apply <strong>force</strong> or <strong>impulse</strong> to a body. The difference is that an impulse is meant to simulate an immediate jolt/kick to the body, while force (and torque) is something exerted over time. Therefore, to get a realistic force/torque simulation, you should continually apply it on every application cycle, for as long as you want the force to continue. You can use a Runtime <a href="../../../api/event/enterFrame/index.html">enterFrame</a> event for this purpose:</p>
<pre class="brush: lua;">local object = display.newImageRect( "leaf.png", 40, 40 )
object.x, object.y = 200,200

physics.addBody( object, "dynamic", { radius=20 } )

local function constantForce()
    object:applyForce( 2, -4, object.x, object.y )
    object:applyTorque( 2 )
end

Runtime:addEventListener( "enterFrame", constantForce )</pre>
</div>
<hr>
<div id="footer">
<p class="copyright">
© 2020-2024 Solar2D All Rights Reserved.
</p>
<p class="feedback">
Help us help you! If you notice a problem with this page, please report it.
</p>
<p><a class="feedback-button" href="https://github.com/coronalabs/corona-docs/issues" target="_blank">Report an Issue</a></p>
</div>
</section>
</section>
</section>
<script src="https://corona-cdn.coronalabs.com/js/SyntaxHighlighter/shCore.js" type="text/javascript"></script>
<script src="https://corona-cdn.coronalabs.com/js/SyntaxHighlighter/shAutoloader.js" type="text/javascript"></script>
<script type="text/javascript">
    // Define syntax highlighting scripts.
    // N.B.: As a safeguard, you will need to whitelist the brush in filter-SyntaxHighlighter.py

    SyntaxHighlighter.autoloader(
      ['c#','https://corona-cdn.coronalabs.com/js/SyntaxHighlighter/shBrushCSharp.js'],
      ['java','https://corona-cdn.coronalabs.com/js/SyntaxHighlighter/shBrushJava.js'],
      ['js','https://corona-cdn.coronalabs.com/js/SyntaxHighlighter/shBrushJScript.js'],
      ['lua','https://corona-cdn.coronalabs.com/js/SyntaxHighlighter/shBrushLua.js'],
      ['php','https://corona-cdn.coronalabs.com/js/SyntaxHighlighter/shBrushPhp.js'],
      ['sql','https://corona-cdn.coronalabs.com/js/SyntaxHighlighter/shBrushSql.js'],
      ['xml','https://corona-cdn.coronalabs.com/js/SyntaxHighlighter/shBrushXml.js']
    );

    // Set default configurations.
    SyntaxHighlighter.defaults['gutter'] = false; // Disable line numbers.
    SyntaxHighlighter.defaults['toolbar'] = false; // Disable link back to author's site. :(
	SyntaxHighlighter.defaults['quick-code'] = false; // Disable double click feature

    // Perform the highlighting.
    SyntaxHighlighter.all();
</script>
</body>
</html>
